use Bitwise
#use MapSet

defmodule CHAINRECTest do
  use ExUnit.Case
  doctest CHAINREC

  test "recursive parse" do
    #CHAINREC.recursive_parse([1])
  end

  @doc """
  This test was done to learn how to use the MapSet structure.
  There were several problems with it, and an issue in gitub was oppened:
  https://github.com/elixir-lang/elixir/issues/8953
  """
  test "crate mapset" do
    terminals = MapSet.new |> MapSet.put("A")
    assert MapSet.member?(terminals, "A") == true
  end

  @doc """
  get the rule's prefix
  """
  test "get rule prefix" do
    rule = "aA"
    terminals = MapSet.new |> MapSet.put("A") |> MapSet.put("B")
    assert CHAINREC.get_add_elements(rule, terminals, "") == "a"
  end

  @doc """
  generates the rule's sub chains until max
  """
  test "generate sub chains" do
    rules_map = Map.new |> Map.put("A","aA") |> Map.put("B","bB")
    terminals = MapSet.new |> MapSet.put("A") |> MapSet.put("B")
    max = 3
    rule = "aA"
    add = CHAINREC.get_add_elements(rule, terminals, "")
    assert CHAINREC.get_subchain(max, [], add, rules_map) == ["a", "aa", "aaa"]
  end

  @doc """
  test to combine lists
  """
  test "combine subchains" do
    list = ["111","21"]
    rule_chains = ["4","5"]
    max = 3
    #assert CHAINREC.combine_lists(list,rule_chains,max,[]) == ["214","215"]
  end

  @doc """
  given a rule, get the possible subchains
  """
  test "rule subchains" do
    max = 3
    rules_map = Map.new |> Map.put("A","aA") |> Map.put("B","bB")
    terminals = MapSet.new |> MapSet.put("A") |> MapSet.put("B")
    terminal = "A"
    rule = rules_map[terminal]
    add = CHAINREC.get_add_elements(rule, terminals, "")
    CHAINREC.get_subchain(max, [], add, rules_map) == ["a","aa","aaa"]
  end

  @doc """
  test to combine possible subchains
  """
  test "get all subchains" do
    first_rule = "AB"
    rules_map = Map.new |> Map.put("A","aA") |> Map.put("B","bB")
    terminals = MapSet.new |> MapSet.put("A") |> MapSet.put("B")
    max = 3
    assert CHAINREC.combine_subchains([], first_rule, rules_map, max, terminals) == ["ab","abb","aab"]
  end

  @doc """
  Final test: check if a chain is generated by grammar
  """
  test "check chain" do
    first_rule = "AB"
    rules_map = Map.new |> Map.put("A","aA") |> Map.put("B","bB")
    terminals = MapSet.new |> MapSet.put("A") |> MapSet.put("B")
    max = 3
    possible_chains_list =  CHAINREC.combine_subchains([], first_rule, rules_map, max, terminals)
    test_chain = "aab"
    possible_chains_set = possible_chains_list |> Enum.uniq |> List.to_tuple
    possible_chains_set = MapSet.new(possible_chains_list)
    assert MapSet.member?(possible_chains_set,test_chain) == true
  end
end
