defmodule CHAINREC do
  @moduledoc """
  Documentation for CHAINREC.
  """

  @doc """
  Hello world.

  ## Examples

      iex> CHAINREC.hello()
      :world

  """
  def hello do
    :world
  end

  @doc """
  Parse a set recursively and returns one of its elements
  """
  def rec_parse(set_list) do
    IO.puts(set_list)
    [head| tail] = set_list
    head
    List.delete_at(set_list,0)
    rec_parse(set_list)
  end

  @doc """
  What to do once the list is empty
  """
  def rec_parse(set_list) when set_list == nil do
    IO.puts("end of list")
  end

  @doc """
  Generates all possible chains given grammar and maximum size
  grammar  -> tuple
  max_size -> integer
  """
  def gen_chain(grammar, max_size) do
    # get terminals and the initial symbol
    T = elem(grammar, 0)
    Rules = elem(grammar, 1)
    Init_sym = elem(grammar, 2)

    # Chains list, originally empty
    # List of MapSets
    chains = []

    # For every rule Rx in R list, create possible chains
    Enum.map(Rules, fn Rx -> chains = [gen_chains_rule(Rx, max_size) | chains] end)

    # Returns the final list of possible chains
    chains

  end

  @doc """
  Receives a rule such as A -> a and returns all possible chains with max_size
  rule -> tuple of strings
  max_size -> int
  """
  def gen_chains_rule(rule, max_size) do
    # list of possible chains
    chains = []

    # gets the possible chain members in tail
    [head | tail] = rule

    #adds iteratively until the chain size is equal or bigger than max_size
    add_new_chain(tail, max_size, chains)

    chains
  end

  @doc """
  Function to add a new member to chains recursively
  """
  def add_new_chain(element, max_size, chains) do
    # get last chain
    last_chain = last(chains)

    # add an extra element to the end of the list
    # and add the result to the general list of chains
    chains = [chains | [last_chain | element]]

    # call it recursively (max_size) times
    add_new_chain(element, max_size - 1, chains)
  end


  @doc """
  When max_size is reached
  """
  def add_new_chain(rule, max_size, chains) when max_size == 1 do
    # get last chain
    last_chain = last(chains)

    # add an extra element to the end of the list
    # and add the result to the general list of chains
    chains = [chains | [last_chain | element]]

    # return chains
    chains
  end

  @doc """
  Check if a chain is valid given a certain grammar
  """
  def recognition(tape, grammar, max_size) do
    # generates possible chains given grammar
    chains = gen_chain(grammar,max_size)

    # checks if tape is in chains
    if (MapSet.member?(chains, tape)) do # tape can be generated by grammar
      IO.puts(true)
      true
    else
      IO.puts(false) # tape cannot be generated by grammar
      false
    end
  end
end
